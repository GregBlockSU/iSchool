boxplot(mpg ~ gear, data = mtcars, col = "orange", main = "Gears", ylab=NULL, xlab="(gear count)")
boxplot(mpg ~ hp, data = mtcars, col = "blue", main = "Horsepower", ylab=NULL, xlab="(foot-pounds-per-second)")
mtext(~ bold("Motor Trend Cars - MPG"), side=3, col="blue", line=-1.5,outer=TRUE)
par(mfrow=c(1,1))
#install.packages("ggpubr")
library(ggpubr)
p1 <- ggplot(iris, aes(x = Sepal.Length)) +
geom_density(aes(fill = Species))+
labs(title="Combined")
p2 <- ggplot(iris, aes(x = Sepal.Length)) +
labs(title="Faceted") +
geom_density(aes(color=Species)) +
facet_wrap(~Species)
ggarrange(p1, p2, ncol = 2, nrow = 1)
plot(mtcars)
library(ggplot2)
ggplot(diamonds, aes(x = cut, y = price, fill = cut)) +
geom_boxplot(outlier.colour="black", outlier.shape=16, outlier.size=2)
library(ggplot2)
ggplot(diamonds, aes(x = cut, y = price, fill = cut)) +
geom_boxplot(outlier.colour="red", outlier.shape=16, outlier.size=1.5)+
labs(title="Diamond price distribution by cut")
library(ggplot2)
ggplot(diamonds, aes(x = cut, y = price, fill = cut)) +
geom_boxplot(outlier.colour="red", outlier.shape=14, outlier.size=1.2)+
labs(title="Diamond price distribution by cut")
library(ggplot2)
ggplot(diamonds, aes(x = cut, y = price, fill = cut)) +
geom_boxplot(outlier.colour="red", outlier.shape=15, outlier.size=1.2)+
labs(title="Diamond price distribution by cut")
library(ggplot2)
ggplot(diamonds, aes(x = cut, y = price, fill = cut)) +
geom_boxplot(outlier.colour="red", outlier.shape=16, outlier.size=1.2)+
labs(title="Diamond price distribution by cut")
summary(BOD)
rainfall <- c(0,0,0,2,1,1,4)  # Amount of rain each day this week
sum(rainfall) / length(rainfall)  # Compute the mean the hard way
mean(rainfall) # Use a function to compute the mean
# Only if you did not do this in the Introduction
install.packages("modeest")  # Download the mode estimation package
library(modeest) # Make the package ready to use
mfv(rainfall) # mfv stands for most frequent value
votes <- c(200,300,400) # Here is scenario one
(votes - mean(votes)) ^ 2 # Show a list of squared deviations
sum( (votes - mean(votes)) ^ 2) # Add them together
sum( (votes - mean(votes)) ^ 2) / length(votes) # Divide by the number of observations
votes1 <- c(200,300,400) # Here is scenario one again
sqrt( sum((votes1 - mean(votes1))^2) / length(votes1) ) # That is the standard deviation
votes2 <- c(299,300,301) # Here is scenario two
sqrt( sum((votes2 - mean(votes2))^2) / length(votes2) ) # And the same for candidate 2
# The commented code makes a high res plot when run in R
#png("Figure01_1.png", width = 6, height = 6, units = 'in', res = 300)
hist( rnorm(n=1000, mean=100, sd=10), main=NULL )
# The commented code makes a high res plot when run in R
#png("Figure01_1.png", width = 6, height = 6, units = 'in', res = 300)
hist( rnorm(n=1000, mean=100, sd=10), main=NULL )
rainfall <- c(0,0,0,2,1,1,4) 		# Amount of rain each day this week
rainfall <- c(0,0,0,2,1,1,4) 		# Amount of rain each day this week
rainfall
rainfall <- c(0,0,0,2,1,1,4) 		# Amount of rain each day this week
rainfall
#install.packages("modeest")
library("modeest")
sum(rainfall)
length(rainfall)
rainfall_mean <- sum(rainfall) / length(rainfall) 	# Compute the mean the hard way
mean(rainfall)
# Only if you did not do this in the Introduction
#install.packages("modeest") 	# Download the mode estimation package
#library(modeest)			# Make the package ready to use
mfv(rainfall)				# mfv stands for most frequent value
# Only if you did not do this in the Introduction
#install.packages("modeest") 	# Download the mode estimation package
#library(modeest)			# Make the package ready to use
Mfv(rainfall)				# mfv stands for most frequent value
# Only if you did not do this in the Introduction
#install.packages("modeest") 	# Download the mode estimation package
#library(modeest)			# Make the package ready to use
mfv(Rainfall)				# mfv stands for most frequent value
Rainfall <- 0
mfv(Rainfall)
source("C:/Users/gregb/OneDrive/Courses/Syracuse/Courses/772/Weeks/01/textbook-week-1.R", echo=TRUE)
source("C:/Users/gregb/OneDrive/Courses/Syracuse/Courses/772/Weeks/01/textbook-week-1.R", echo=TRUE)
rainfall <= c(0,0,0,2,1,1,4) 		# Amount of rain each day this week
data()
summary(InsectSprays)
#'**Exercise 4**
#'
#'As in the previous exercise, use the data() function to get a list of the data sets that are
#'included with the basic installation of R. Choose a data set that includes just one variable,
#'for example, the LakeHuron data set (levels of Lake Huron in the years 1875 through 1972).
#'Use the hist() command to create a histogram of the variableâ€”for exaple, hist(LakeHuron). Describe the shape of the histogram in words. Which of the distribution types do you think these data fit most closely (e.g., normal, Poisson). Speculate on why your selected data may fit that distribution.
#'
#'Histogram of Nile dataset
hist(Nile)
m <- .75
m
# a few more simple statements
x <- 10
b <- 7
y <- m * x + b
y
# displays the value '5' in the console window
sqrt(25)
z <- sqrt(y)
z
# note that a function name is followed by open & closing parenthesis; within
# the parantheses you can provide the input parameters to the function
f
myList <- c(21, 12, 17, 14)
myList
pie(myList)
barplot(myList)
? barplot
# note that the parameters main, ylab and xlab are specified by name, using
# the notation name = value; whereas the variable myList is passed by position
barplot(myList, main = 'Tortoise burrows', ylab = 'Feet', xlab = 'Tortoise')
# we can also change the orientation to horizontal using the horiz parameter
barplot(myList, main = 'Tortoise burrows', ylab = 'Feet', xlab = 'Tortoise',
horiz = TRUE,
names.arg = c('Felix', 'OddOne', 'Scamper', 'Blue'))
# let's use the c() function to create a list of colors
myColors <- c('green', 'red', 'purple', 'blue')
barplot(myList, main = 'Tortoise burrows', ylab = 'Feet', xlab = 'Tortoise',
horiz = TRUE,
col = myColors,
names.arg = c('Felix', 'OddOne', 'Scamper', 'Blue'))
# the dev.off() command clears the current plot
dev.off()
# graphics.off() clears all plots
graphics.off()
# for help on rnorm(), typpe "? rnorm"
? rnorm
# use set.seed to generate repeatable results
set.seed(123)
x <- rnorm(5000)
y <- x + rnorm(5000)
# inspect the two variables
summary(x)
summary(y)
# let's plot the two variables using a histogram
hist(x, main = 'The x distribution')
hist(y, main = 'The y distribution')
plot(x, y)
? par
par(mfrow = c(1, 3))
hist(x, main = 'The x distribution')
hist(y, main = 'The y distribution')
plot(x, y)
par(mfrow = c(3, 1))
hist(x, main = 'The x distribution')
hist(y, main = 'The y distribution')
plot(x, y)
m <- .75
m
# a few more simple statements
x <- 10
b <- 7
y <- m * x + b
y
# displays the value '5' in the console window
sqrt(25)
z <- sqrt(y)
z
myList <- c(21, 12, 17, 14)
myList
pie(myList)
barplot(myList)
? barplot
# note that the parameters main, ylab and xlab are specified by name, using
# the notation name = value; whereas the variable myList is passed by position
barplot(myList, main = 'Tortoise burrows', ylab = 'Feet', xlab = 'Tortoise')
# we can also change the orientation to horizontal using the horiz parameter
barplot(myList, main = 'Tortoise burrows', ylab = 'Feet', xlab = 'Tortoise',
horiz = TRUE,
names.arg = c('Felix', 'OddOne', 'Scamper', 'Blue'))
# let's use the c() function to create a list of colors
myColors <- c('green', 'red', 'purple', 'blue')
barplot(myList, main = 'Tortoise burrows', ylab = 'Feet', xlab = 'Tortoise',
horiz = TRUE,
col = myColors,
names.arg = c('Felix', 'OddOne', 'Scamper', 'Blue'))
# the dev.off() command clears the current plot
dev.off()
# graphics.off() clears all plots
graphics.off()
# for help on rnorm(), typpe "? rnorm"
? rnorm
# use set.seed to generate repeatable results
set.seed(123)
x <- rnorm(5000)
y <- x + rnorm(5000)
# inspect the two variables
summary(x)
summary(y)
# let's plot the two variables using a histogram
hist(x, main = 'The x distribution')
hist(y, main = 'The y distribution')
plot(x, y)
? par
par(mfrow = c(1, 3))
hist(x, main = 'The x distribution')
hist(y, main = 'The y distribution')
plot(x, y)
par(mfrow = c(3, 1))
hist(x, main = 'The x distribution')
hist(y, main = 'The y distribution')
plot(x, y)
knitr::opts_chunk$set(echo = TRUE)
# IST 421 Lab 2
# Dr. Gregory Block
# we want to use special formatting to display our tables, so we need to install
# a 'package' called formattable; this is usually a one-time action (unless there)
# are updates to the package
#install.packages('formattable')
# however, whenever we want to USE the package after it's downloaded, we
# need to specify the library in each R module using the library command
library(formattable)
knitr::opts_chunk$set(echo = TRUE)
# IST 421 Lab 2
# Dr. Gregory Block
# we want to use special formatting to display our tables, so we need to install
# a 'package' called formattable; this is usually a one-time action (unless there)
# are updates to the package
#install.packages('formattable')
# however, whenever we want to USE the package after it's downloaded, we
# need to specify the library in each R module using the library command
library(formattable)
knitr::opts_chunk$set(echo = TRUE)
# IST 421 Lab 2
# Dr. Gregory Block
# we want to use special formatting to display our tables, so we need to install
# a 'package' called formattable; this is usually a one-time action (unless there)
# are updates to the package
#install.packages('formattable')
# however, whenever we want to USE the package after it's downloaded, we
# need to specify the library in each R module using the library command
library(formattable)
# the purpose of this exercise is to use the R Markdown feature to
# work with data frames and generate plots
# first we display characteristics of the mtcars data frame
# the summary command will display characteristics of each of the
# variables in the mtcars data frame
colnames(mtcars)
summary(mtcars)
# next we want to display the contents of the mtcars data frame
# using the formattable library
formattable(mtcars)
# next we can try generating a simple plot
plot(mtcars$hp, mtcars$mpg, main='mpg vs horsepower',
xlab='horsepower', ylab='MPG', pch=19, col='blue')
# next let's create a new data frame
# a data frame is like a 2-dimensional list; the data frame is comprised
# of rows (like a list) and each element in the list of rows is described
# by one or more columns
# the columns have names, which you can list using the colnames function
# columns are also called variables
burrows <- data.frame(name = c('Felix', 'OddOne', 'Scamp', 'Blue'),
dug = c(21, 12, 17, 14),
age = c(47, 23, 2, 14))
colnames(burrows) # name, dug, age
formattable(burrows)
# next let's create a new data frame
# a data frame is like a 2-dimensional list; the data frame is comprised
# of rows (like a list) and each element in the list of rows is described
# by one or more columns
# the columns have names, which you can list using the colnames function
# columns are also called variables
burrows <- data.frame(name = c('Felix', 'OddOne', 'Scamp', 'Blue'),
dug = c(21, 12, 17, 14),
age = c(47, 23, 2, 14))
colnames(burrows) # name, dug, age
formattable(burrows)
# next let's create a new plot using the burrows data frame and
# the plot definition from a prior lesson
# to access
myColors <- c('green', 'red', 'purple', 'blue')
# we want to plot the depth of the burrows each tortoise dug, so
# we will access the 'dug' variable from the burrows data frame
# to do so we use the subset operator $, as in burrows$dug
# we can also access the tortoises' names by accessing the name variable
# as in burrows$name
barplot(burrows$dug, main = 'Tortoise burrows', ylab = 'Feet', xlab = 'Tortoise',
horiz = TRUE,
col = myColors,
names.arg = burrows$name)
# use set.seed to generate repeatable results
set.seed(123)
# generate sample data in the x and y variables; note that we are reusing
# the x variable from the start of the lecture
x <- rnorm(5000)
y <- x + rnorm(5000)
# inspect the two variables
summary(x)
summary(y)
# change the default parameters to allow more than one plot in a panel
par(mfrow = c(1, 3))
# now generate three plots in the same panel
hist(x, main = 'The x distribution')
hist(y, main = 'The y distribution')
plot(x, y)
#library(vctrs)
#library(knitr)
library(dplyr)
#library(tibble)
library(readr)
#library (glue)
library(stringr)
#library(tidyverse)
library(ggplot2)
library(ggmap)
# set the working folder to "Week 3"
setwd("C:/repos/SU/iSchoo/CSP/421/Labses")
getwd()
# set the working folder to "Labses"
setwd("C:/repos/SU/iSchool/CSP/421/Labses")
getwd()
fileName <- "data/nst-est2011-01.csv";
census <- read.csv(fileName)
# you can also open a file using an absolute reference; an absolute reference
# starts with a drive letter or has the "/" as its first character
fileName <- "C:/repos/SU/iSchool/CSP/421/Labses/data/nst-est2011-01.csv";
census <- read.csv(fileName)
# you can open a file in a folder path that is different than your working folder
fileName <- "/data/nst-est2011-01.csv";
census <- read.csv(fileName)
fileName <- "../Labses/data/nst-est2011-01.csv"
census <- read.csv(fileName)
# here's another example using backslashes, the default Windows path separator
fileName <- "C:\repos\SU\iSchool\CSP\421\Labses\data\nst-est2011-01.csv";
# in order to use the backslash as a folder seperator, you must double them up
fileName <- "C:\\repos\\SU\\iSchool\\CSP\\421\\Labses\\data\\nst-est2011-01.csv";
census <- read.csv(fileName)
census_url <- paste0("https://www2.census.gov/programs-surveys/",
"popest/tables/2010-2011/state/totals/nst-est2011-01.csv")
dfStates <- read.csv(url(census_url), stringsAsFactors = FALSE)
# dfStates contains our data set, so let's save the file locally
# note that you may need to change the target location of the file
write.csv(dfStates, "c:/data/nst-est2011-01.csv")
# explore the dataset
nrow(dfStates)
colnames(dfStates)
# 66
ncol(dfStates)
colnames(dfStates)
head(dfStates)
summary(dfStates)
dfStates <- dfStates %>%
slice(-1:-8) %>%
select(1:5) %>%
slice (-52:-58) %>%
#define column Names
rename(
"stateName"=1,
"Census"=2,
"Estimated"=3,
"Pop2010"=4,
"Pop2011"=5)
# remove dots
dfStates$stateName <- str_replace_all(dfStates$stateName, "\\.", "")
# remove spaces and convert to numeric type
dfStates$Census <- as.numeric(str_replace_all(dfStates$Census, ",", ""))
dfStates$Estimated <- as.numeric(str_replace_all(dfStates$Estimated, ",", ""))
dfStates$Pop2010 <- as.numeric(str_replace_all(dfStates$Pop2010, ",", ""))
dfStates$Pop2011 <- as.numeric(str_replace_all(dfStates$Pop2011, ",", ""))
#Make sure everything is lowercase
dfStates$state <- tolower(dfStates$stateName)
View(dfStates)
head(dfStates)
df <- dfStates[order(dfStates$Census,decreasing = TRUE),]
View(dfStates)
df <- df[order(-df$Census),][1:5,]
View(dfStates)
barplot(df$Census / 1000000,
main = '2010 Census',
xlab = 'States',
ylab = 'Population (millions)',
names.arg = df$stateName)
df <- df[order(-df$Census),][1:5,]
barplot(df$Census / 1000000,
main = '2010 Census',
xlab = 'States',
ylab = 'Population (millions)',
names.arg = df$stateName)
ggplot(
df,
aes(x = stateName, Census/1000000)) +
geom_bar(stat = "identity") +
geom_text(aes(x = stateName, label = round(Census/1000000, 2)), nudge_y = 3) +
labs(x = "Top 6 States", y = "Census (in Millions)"
)
ggplot(df,
aes(x = reorder(stateName, -Census),Census/1000000)) +
geom_bar(stat = "identity") +
geom_text(aes(x = stateName, label = round(Census/1000000, 2)), nudge_y = 3) +
labs(x = "Top 6 States", y = "Census (in Millions)")
# rather than gray, let's use a gradient color, the higher the number,
# the darker the color
ggplot(df,
aes(x = reorder(stateName, -Census),Census/1000000)) +
geom_bar(stat = "identity", aes(fill = -Census), show.legend = FALSE) +
geom_text(aes(x = stateName, label = round(Census/1000000,2)), nudge_y = 3) +
labs(x = "Top 6 States", y = "Census (in Millions)")
# be sure to install ggplot2
# install.packages("ggplot2")
library("ggplot2")
# create dummy data to illustrate the ggplot colors
data <- data.frame(x = 1:9, y = 1:9)
# data is a data frame with 9 rows and 2 columns
data
ggp <- ggplot(data, aes(x, y, col = factor(x))) +
geom_point(size = 10)
ggp
# be sure to install ggplot2
# install.packages("RColorBrewer")
library("RColorBrewer")
# add the scale colors to our ggp graph and display
# using a variety of palettes
ggp + scale_colour_brewer(palette = 3)
ggp + ?scale_colour_brewer(palette = 7)
ggp + scale_colour_brewer(palette = 'Blues')
ggp + scale_colour_brewer(palette = 'Greens')
# display all the palettes
display.brewer.all(colorblindFriendly = TRUE)
# Generate some data
set.seed(133)
df <- data.frame(xval=rnorm(50), yval=rnorm(50))
# Make color depend on yval
ggplot(df, aes(x=xval, y=yval, colour=yval)) +
geom_point()
# load the mtcars data frame
data(mtcars)
p <- ggplot(mtcars, aes(wt, mpg))
p + geom_point()
# set the color to the # of cylinders
p + geom_point(aes(colour = factor(cyl)))
# set the shape to the # of cylinders
p <- ggplot(mtcars, aes(mpg, wt, shape = factor(cyl))) +
geom_point(aes(colour = factor(cyl)), size = 4) +
geom_point(colour = "grey45", size = 1)
p
# using gradient values based on the dat
# set the seed to ensure the random distribution is the same each time
set.seed(1234)
x <- rnorm(200)
length(x)
summary(x)
# create a basic  histogram from x
hist<-qplot(x =x, fill=-..count.., geom="histogram")
#display it
hist
# change the color scheme to sequential gradient, with
# the low frequency in green, shifting to red as
# the frequency increases
hist + scale_fill_gradient(low="red", high="green")
# load the tidyverse and gghilight libraries
#install.packages('tidyverse')
#install.packages('gghighlight')
library(tidyverse)
library(gghighlight)
# The current/active theme (see theme()) is automatically applied to every plot
# you draw. Use theme_get() to get the current theme, and theme_set() to
# completely override it. theme_
?theme_set
theme_set(theme_bw())
#load the iris data frame
data(iris)
summary(iris)
# draw a histogram of the iris length, using the
# species as the fill color
ggplot(iris, aes(Sepal.Length, fill = Species)) +
geom_histogram(bins = 30)
ggplot(iris, aes(Sepal.Length, fill = Species)) +
geom_histogram(bins = 30) +
scale_fill_viridis_d()
# the facet wrap will generate a separate graph per species
ggplot(iris, aes(Sepal.Length, fill = Species)) +
geom_histogram(bins = 30) +
scale_fill_viridis_d() +
facet_wrap(~ Species)
# now we can highlight the adjoining bars across all facets
ggplot(iris, aes(Sepal.Length, fill = Species)) +
geom_histogram(bins = 30) +
scale_fill_viridis_d() +
gghighlight() +
facet_wrap(~ Species)
# clear the plots window
dev.off()
# create a 2x2 grid for charts
par(mfrow=c(2,2))
boxplot(mpg ~ am, data = mtcars, col = "pink", main = "Transmission", ylab=NULL, xlab="(Manual/Automatic)")
boxplot(mpg ~ cyl, data = mtcars, col = "yellow", main = "Cylinders", ylab=NULL, xlab="(number)")
boxplot(mpg ~ hp, data = mtcars, col = "blue", main = "Horsepower", ylab=NULL, xlab="(units)")
boxplot(mpg ~ gear, data = mtcars, col = "orange", main = "Gears", ylab=NULL, xlab="(count)")
mtext(~ bold("Motor Trend Cars - MPG"), side=3, col="blue", line=-1.5,outer=TRUE)
par(mfrow=c(1,1))
dev.off()
library(ggplot2)
ggplot(iris, aes(Sepal.Length, fill = Species)) +
geom_histogram(bins = 20) +
scale_fill_viridis_d() +
facet_wrap(~ Species)
# Plot
IrisPlot <- ggplot(iris, aes(Sepal.Length, Petal.Length, colour=Species)) +
geom_point() +
theme(legend.title = element_text(color = "blue", size = 10, face = "bold")) +
geom_point(color="firebrick") +
theme(plot.background = element_rect(fill = 'pink'))
print(IrisPlot)
ggplot(iris, aes(x = Sepal.Length)) +
geom_density(aes(fill = Species))
shiny::runApp('week-6/r-shiny/census-app')
